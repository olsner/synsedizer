#!/usr/bin/env -S sed -rnf
# Polyphonic synsedizer.

:ehold
# Strip comment(s) and leading/trailing whitespace
s/#.*$//g
s/^\s+//
s/\s+$//

# Process known commands
/^r (.*)$/ {
    / 8000$/ {
        s/.*/\x00\x00\x1f\x40/
    }
    / 16000$/ {
        s/.*/\x00\x00\x3e\x80/
    }
    / 44100$/ {
        s/.*/\x00\x00\xac\x44/
    }
    /.* ([0-9]+)$/ {
        s//ERROR: unrecognized sample rate: \1/
        w /dev/stderr
        Q 1
    }
    # start of header: offset to data (28), data size (-1), format (16-bit PCM)
    s/^/.snd\x00\x00\x00\x1c\xff\xff\xff\xff\x00\x00\x00\x03/
    # in the middle: sample rate converted above
    # end of header: number of channels, annotation + padding (4 zeroes), plus
    # one to be the MSB of the first sample (followed by a newline)
    s/$/\x00\x00\x00\x01\x00\x00\x00\x00\x00/p
    beat
}
/^s (.*)$/ {
    # Add sleep. We know there is no sleep yet, as we only read commands when
    # not sleeping.
    s//S\1/g
    H
    bleep
}
/^([abcde]) (.*)$/ {
    s//W\1,1,0,\2,\2/g
    H
    beat
}
/^([ABCDE])$/ {
    s/.*/\L&/
    G
    s/\`(.)\n((.*\n)*)W\1,.*$/\2/m
    s/^.\n//
    h
    beat
}
/^P/ {
    # Print the internal state on stderr for debugging, together with the full
    # P command (which can be used for a message or tag).
    G
    w /dev/stderr
    beat
}
/.+/ {
    # ... and unknown commands
    s/^/ERROR: unrecognized command: /
    w /dev/stderr
    Q 1
}
:eat
z
n
behold

:leep
g

# Remove old accumulator
s/^Ai*(\n|$)//

# If sleep state is not present, read one line of input and process.
/^S/M! {
    beat
}

# Debug trace
#{
#    h
#    # Indent each line of state and add header/footer then print to stderr
#    s/^/  /mg
#    s/^(.*)\n*$/DEBUG: state loop: state {\n&\n} state/
#    w /dev/stderr
#    g
#}

# Append initial accumulator value (5) at end, then shift through state list
# from the start until we reach the accumulator again.
s/\n*$/\nAiiiii/

:loop
# Strip leading newlines
s/^\n+//

# Sleep state (finished):
s/^S\n//g

# Sleep state:
/^S/ {
    s/^(Sm*)m$/\1cccccccccc/m
    s/^(S[mc]*)c$/\1xxxxxxxxxx/m
    s/^(S[mcx]*)x$/\1iiiiiiiiii/m
    s/^(S[mcxi]*)i$/\1/m
    # Still sleeping to do, shuffle and continue
    s/^(S[mcxi]+)\n(.*)$/\2\n\1/
}
# Wave state: W<id>,<phase>,<next-phase>,<initial wavelength>,<counter>
/^W/ {
    # increment/decrement accumulator according to phase
    /^W([^,]*),1,/ s/^A/Ai/mg
    /^W([^,]*),0,/ s/^Ai/A/mg
    # Decrement counter
    s/\`(W.*,m*)m$/\1cccccccccc/m
    s/\`(W.*,[mc]*)c$/\1xxxxxxxxxx/m
    s/\`(W.*,[mcx]*)x$/\1iiiiiiiiii/m
    s/\`(W.*,[mcxi]*)i$/\1/m
    # if WL counter 0: reset WL counter to initial WL, flip phase
    /\`W.*,$/M {
        s/^(W[^,]*)(,[01])(,[01])(,[mcxi]+),$/\1\3\2\4\4/m
    }
    # Shuffle and continue
    s/^([^\n]+)\n(.*)$/\2\n\1/g
}
# Accumulator (also finished processing this sample)
/^A/ {
    h
    # Strip away the non-accumulator part
    s/\n.*$//
    # ASCII Debug output:
#    s/^/Output: /p
    # Binary 8-bit unsigned output with 10 steps plus middle (enough headroom
    # for the worst case of all five voices coming into phase).
    /^Aiiiii/ {
        s/^Aiiiiiiiiii+$/\x7f/p
        s/^Aiiiiiiiii$/\x66/p
        s/^Aiiiiiiii$/\x4c/p
        s/^Aiiiiiii$/\x33/p
        s/^Aiiiiii$/\x19/p
        s/^Aiiiii$/\x00/p
        bleep
    }
    s/^Aiiii$/\xe7/p
    s/^Aiii$/\xcd/p
    s/^Aii$/\xb4/p
    s/^Ai$/\x9a/p
    s/^A$/\x81/p
    bleep
}

bloop

bleep

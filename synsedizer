#!/usr/bin/env -S sed -rnf
# Polyphonic synsedizer.

:ehold
# Strip comment(s) and leading/trailing whitespace
s/#.*$//g
s/^\s+//
s/\s+$//

# Process known commands
/^r (.*)$/ {
    / 8000$/ {
        s/.*/\x00\x00\x1f\x40/
    }
    / 16000$/ {
        s/.*/\x00\x00\x3e\x80/
    }
    / 44100$/ {
        s/.*/\x00\x00\xac\x44/
    }
    /.* ([0-9]+)$/ {
        s//ERROR: unrecognized sample rate: \1/
        w /dev/stderr
        Q 1
    }
    # start of header: offset to data (28), data size (-1), format (16-bit PCM)
    s/^/.snd\x00\x00\x00\x1c\xff\xff\xff\xff\x00\x00\x00\x03/
    # in the middle: sample rate converted above
    # end of header: number of channels, annotation + padding (4 zeroes), plus
    # one to be the MSB of the first sample (followed by a newline)
    s/$/\x00\x00\x00\x01\x00\x00\x00\x00\x00/p
    beat
}
/^s (.*)$/ {
    # Add sleep. We know there is no sleep yet, as we only read commands when
    # not sleeping.
    s//S\1/g
    H
    bleep
}
/^([abcde]) (.*)$/ {
    s//W\1,1,0,\2,\2/g
    H
    beat
}
/^([ABCDE])$/ {
    s/.*/\L&/
    G
    s/\`(.)\n((.*\n)*)W\1,.*$/\2/m
    s/^.\n//
    h
    beat
}
/^P/ {
    # Print the internal state on stderr for debugging, together with the full
    # P command (which can be used for a message or tag).
    G
    w /dev/stderr
    beat
}
/.+/ {
    # ... and unknown commands
    s/^/ERROR: unrecognized command: /
    w /dev/stderr
    Q 1
}
:eat
z
n
behold

:leep
g

# Remove old accumulator
s/^Ai*(\n|$)//

# If sleep state is not present, read one line of input and process.
/^S/M! {
    beat
}

# Debug trace
#{
#    h
#    # Indent each line of state and add header/footer then print to stderr
#    s/^/  /mg
#    s/^(.*)\n*$/DEBUG: state loop: state {\n&\n} state/
#    w /dev/stderr
#    g
#}

# Append initial accumulator value (5) at end, then shift through state list
# from the start until we reach the accumulator again.
s/\n*$/\nAiiiii/

:loop
# Strip leading newlines
s/^\n+//

# Sleep state: shuffle to end of state and add decrement marker.
/^S/ s/^(S[0-9]*)\n(.*)$/\2\n\1-/

# Wave state: W<id>,<phase>,<next-phase>,<initial wavelength>,<counter>
/^W/ {
    # increment/decrement accumulator according to phase
    /^W([^,]*),1,/ s/^A/Ai/mg
    /^W([^,]*),0,/ s/^Ai/A/mg
    # rotate and add decrement
    s/^(W[^\n]+)\n(.*)$/\2\n\1-/
}
# Loop until the accumulator goes first
/^A/! bloop

# Process all decrements
:dec
s/9-/8/g
s/8-/7/g
s/7-/6/g
s/6-/5/g
s/5-/4/g
s/4-/3/g
s/3-/2/g
s/2-/1/g
s/1-/0/g
# trim leading zeroes (for easier zero matching later)
s/([^0-9]|^)0+([0-9])/\1\2/g
# Don't go past 0
s/([^0-9]|^)0-/\10/g
# Borrow
s/0-/-9/g
tdec

# Sleep state (finished):
s/\nS0//g

# any waves that have reached 0: reset WL counter to initial WL and flip phase
s/^(W[^,]*)(,[01])(,[01])(,[0-9]+),0$/\1\3\2\4\4/mg

/^A/ {
    h
    # Strip away the non-accumulator part
    s/\n.*$//
    # ASCII Debug output:
#    s/^/Output: /p
    # Binary 8-bit unsigned output with 10 steps plus middle (enough headroom
    # for the worst case of all five voices coming into phase).
    /^Aiiiii/ {
        s/^Aiiiiiiiiii+$/\x7f/p
        s/^Aiiiiiiiii$/\x66/p
        s/^Aiiiiiiii$/\x4c/p
        s/^Aiiiiiii$/\x33/p
        s/^Aiiiiii$/\x19/p
        s/^Aiiiii$/\x00/p
        bleep
    }
    s/^Aiiii$/\xe7/p
    s/^Aiii$/\xcd/p
    s/^Aii$/\xb4/p
    s/^Ai$/\x9a/p
    s/^A$/\x81/p
}

bleep
